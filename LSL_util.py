import time
from matplotlib import pyplot as plt
from pylsl import StreamInfo, StreamOutlet
import tkinter as tk
import pyxdf as xdf
import numpy as np
import multiprocessing as mp


    #################################### MULTI PROCESSING SECTION #####################################
#
# def create_workers(processes : list, args=None) -> None:
#     """
#     Create parallel processes
#     :param processes: List of function:                                   [func1,     func2,  ...]
#     :param args: List of Lists additional arguments for the function      [[*args1], [*args2],...]
#     NOTE: len(args) MUST BE EQUAL to len(processes)
#     """
#
#     # Sanity check
#     if not args:
#         args = [[] for i in range(len(processes))]
#
#     labeled_args = []
#     # Label the stream with unique ID
#     LSLstreamID = 1
#     for ar in args:
#         labeled_args.append([LSLstreamID, *ar])
#         LSLstreamID += 1
#
#     # More sanity check
#     if len(args) != len(processes):
#         raise Exception("Not enough arguments for the functions! Should be {} but {} were given".format(len(processes),
#                         len(args))+"\nNote: If a function doesn't require arguments, just put (None,) as args")
#
#     for i in range(len(processes)):
#         p = mp.Process(target=processes[i], args=(*labeled_args[i],))
#         p.start()
#
#         ######################################## DEMO DATA SECTION ########################################
#
# def demo_data_rand(id : int) -> None:
#     print("worker ID: ",id)
#     info = StreamInfo(name='Demo Random',source_id='myuid{}'.format(id))
#     print("worker {} stream info created".format(id))
#     outlet = StreamOutlet(info)
#     print("worker {} outlet info created".format(id))
#     while True:
#         mysample = [np.random.randint(-10,20)]
#         outlet.push_sample(mysample)
#         time.sleep(0.01)
#
# def demo_data_line(id : int) -> None:
#     print("worker ID: ",id)
#     info = StreamInfo(name='Line Random', source_id='myuid{}'.format(id))
#     print("worker {} stream info created".format(id))
#     outlet = StreamOutlet(info)
#     print("worker {} outlet info created".format(id))
#     mysample = [10]
#     while True:
#         outlet.push_sample(mysample)
#         time.sleep(0.01)
#
#
# def create_worker(id, data):
#     print("worker ID: ", id)
#     info = StreamInfo(name='Move{}'.format(id))
#     print("worker {} stream info created".format(id))
#     outlet = StreamOutlet(info)
#     print("worker {} outlet info created".format(id))
#     mysample = [data]
#     while True:
#         outlet.push_sample(mysample)
#         time.sleep(0.01)
#
# def connect_demo_to_lsl():
#     """
#     Generate two demo streams : Random and Line, and connect them to LSL
#     """
#     workers = [demo_data_line, demo_data_rand]
#     create_workers(workers)

def plot_data(filename : str) -> None:
    """
    Plot the data saved from a LSL run
    The data should be in .xdf format, generated by the LSL labRecorder.
    The shape of the data is as follows:
        |>data is list of streams [stream1, stream...], We only interested in stream=0
        |
        ----|>data[0] is a dictionary of attributes.
            |
            |--->data[0]['time_series'] is the time series of the session,
            |        it's shape: (T, CH), where T - the total interval, and CH - the number of channels.
            |        NOTE: if CH == 2, meanly two channels recorded, than only 1 hand was involved.
            |--->data[0]['type'] is a dictionary contains the information:
                {
                "Grid" : Specify the grid was in used in the session (Rectangle or Circular)
                "Origin" : Specify the origin was used in the session (Center, Bottom-center, or Bottom-left)
                "Ransom Sound" : Specify oif the sound data was randomly generated or not (True or False)
                }
    :param filename: path to the file contains the data
    """
    data, header = xdf.load_xdf(filename)

    # extract data in shape of (N, T)where N is number of channels and T is total interval
    numeric_data = data[0]['time_series'].T
    interval = np.arange(numeric_data.shape[1])
    print(numeric_data.shape[1])
    exit()

    # extract x and y: even indices in the data are the x coordinates and odd are the y coordinates
    x_coor = numeric_data[::2, :]   # even indices <=> odd places of rows
    y_coor = numeric_data[1::2, :]  # odd indices <=> even places of rows

    # plot each channel with an appropriate label
    for ch in enumerate(zip (x_coor, y_coor)):
        plt.plot(interval, ch[1][0], label='ch %d, x axis' % (ch[0]+1))
        plt.plot(interval, ch[1][1], label='ch %d, y axis' % (ch[0]+1))
        plt.legend()
    plt.show()


if __name__ == "__main__":
    demo_data_filename = r'C:\Users\yoavsha\Desktop\LSL\Recordings\sub-P001\ses-S001\eeg\sub-P001_ses-S001_task-Default_run-001_eeg.xdf'
    plot_data(demo_data_filename)