from os import environ
environ['SDL_VIDEODRIVER'] = 'windows'
import time
from kivy.app import App
from kivy.clock import Clock
from kivy.core.window import Window
from kivy.uix.widget import Widget
from pylsl import StreamInfo, StreamOutlet
from pythonosc.udp_client import SimpleUDPClient
import numpy as np


# UDP details
IP = "127.0.0.1"
CLIENT_PORT = 2222
SERVER_PORT = 2223
SEND_TO_LSL = False

########################## Developing section ###############################
# Turn this on if you want to print the data generated by th machine
PRINT_DATA = False
# Turn this on if you are currently without a touch pad, and want enable mouse touches
MOUSE_DEV_MODE = False
# Full window switch
FULL_WINDOW = True
######################## END developing section #############################

# Determines how many different touch detections can be realized by the MaxPatches machine as different channels
CHANNELS = 2
# Scale of the time series
TIME_SERIES_DT = 0.01

# The shape of the grid
GRID_dict = {
                "Circular" : 1,
                "Rectangle" : 2
            }

# The origin of the grid
ORIGIN_dict = {
                "Bottom_left" : [0.0, 0.0],
                "Center" : [0.5, 0.5],
                "Center_bottom" : [0.5, 0],
            }

# The actual parameters fed into the machine
ORIGIN = "Bottom_left"
GRID = "Rectangle"

# don't change this:
parameters = [ORIGIN, GRID]
TOUCH_MAX_RADIUS = 0.43
TOUCH_MIN_RADIUS = 0.03
GROUPY_THRESHOLD = 0.27
MIN_TOUCH_TIME = 0.08
SUSTAIN_TIME = -10      # The higher this value, the faster Sustain reach to maximum


class TouchChannel:
    """
    TouchChannel is a wrapper for the input (touch events), in order to get a sense of a human-hand touch.
    As there might be many inputs, the channel considers only one input as the main touch.
    If there are more touch surround it (i.e. participant uses it's all fingers), they considered as 'groupies'.
    If the main touch disconnected, but there are still some groupies - one of them become the main touch.
    A channel starts as not-active. When a touch event occurs, the 'TouchInput'(Widget) object connect it to the first
    available channel and then activate the channel.
    """
    max_area = TOUCH_MAX_RADIUS
    min_area = TOUCH_MIN_RADIUS
    dt = TIME_SERIES_DT  # The delta in time which used to calculate velocity
    sustain_dt = SUSTAIN_TIME
    CH_ID = 0

    def __init__(self, origin, grid):
        # identity attributes
        TouchChannel.CH_ID += 1
        self.channel_id = TouchChannel.CH_ID
        self.id = TouchChannel.CH_ID
        self.origin = ORIGIN_dict[origin]
        self.grid = GRID_dict[grid]
        self.origin_string = origin
        self.grid_string = grid

        # data-generating related
        self.touch_time = 0
        self.start_pos = [0.0, 0.0]
        self.max_norm = np.linalg.norm(np.array([1, 1]) - self.origin)
        self.reduce_time_threshold = self.max_norm / 300  # ||pos - prev_pos|| > threshold => reduce time_touch
        self.mode = 0
        # initialize the values to zero
        self.deactivate()
        update_sustain_event = Clock.schedule_interval(self.update_sustain, self.dt)

    def activate(self, touch):
        """When a touch event is connected to the deactivated channel"""
        self.main_touch = touch
        self.start_pos = [self.main_touch.osx, self.main_touch.osy]
        self.velocity = 0.0
        self.touch_time = 0.0
        self.switch = True

    def deactivate(self):
        """When the main touch is disconnected, and there are no more groupies"""
        self.main_touch = None
        self.prev_pos_time = time.time()
        self.velocity = 0.0
        self.touch_time = 0
        self.switch = False
        self.group = []

    def update_sustain(self, dt):
        """Every period of dt (in sec.), update the self.touch_time & self.velocity attributes"""
        if self.isActive():
            self.touch_time += dt
            self.velocity = np.linalg.norm([self.main_touch.dsx, self.main_touch.dsy]) * 13

    def change_main_touch(self, touch):
        """When the main touch event is terminated and need to be switched to another"""
        self.main_touch = touch

    def isActive(self):
        return self.switch

    def get_main_touch(self):
        return self.main_touch

    def get_main_touch_id(self):
        return self.main_touch.id

    def get_channel_id(self):
        return self.channel_id

    def get_pos_as_list(self):
        if not self.isActive():
            return [0.0, 0.0]
        return [self.main_touch.sx, self.main_touch.sy]

    def get_prev_pos(self):
        return [self.main_touch.psx, self.main_touch.psy]

    def get_start_time(self):
        return self.main_touch.time_start

    def get_group(self):
        return self.group

    def remove_from_group(self, groupy):
        self.group.remove(groupy)

    def next_mode(self):
        """When a very short single touch occurs (less then MIN_TOUCH_TIME)"""
        self.mode += 1

    def prev_mode(self):
        """When a very short double-touch occurs"""
        self.mode = max(self.mode - 1, 0)

    def move(self):
        """When a moving, and only moving, occurs"""
        # reduce the time touch value if position is changed a lot
        ds = np.linalg.norm([self.main_touch.dsx, self.main_touch.dsy])
        if ds > self.reduce_time_threshold:
            self.touch_time *= 0.1

    def add_to_group(self, touch):
        """Add a touch event to the group of this one"""
        self.group.append(touch)

    def positional_circular_rep(self) -> list:
        """Generate the circular positional attributes"""
        # 'raw' euclidean distance of the position from the origin
        dist = np.array([self.main_touch.sx, self.main_touch.sy]) - self.origin
        norm = np.linalg.norm(dist)

        # calculate normalized radius. Normalization done by stretching the maximum value to 1.
        radius = np.sqrt(norm / self.max_norm)

        # calculate the angle from the origin
        tan = 0 if dist[0] == 0 else np.abs(np.tanh(dist[1] / dist[0]))
        return [radius, tan]

    def get_positional_data(self):
        """Generate the positional attributes"""
        if self.grid_string == "Circular":
            return self.positional_circular_rep()

        # else => Origin maybe not CENTER
        # If origin is center, the normalization is just *2 for both axis
        elif self.origin_string == "Center":
            return [2 * np.abs(self.main_touch.sx - self.origin[0]), 2 * np.abs(self.main_touch.sy - self.origin[1])]

        # If origin is X center, Y bottom, the normalization is *2 only for X axis
        elif self.origin_string == "Center_bottom":
            return [2 * np.abs(self.main_touch.sx - self.origin[0]), np.abs(self.main_touch.sy - self.origin[1])]

        # else => origin is default (bottom left), no normalization required
        else:
            return self.get_pos_as_list()

    def get_velocity(self):
        """Calculate velocity in respect to time interval of self.dt"""
        return self.velocity

    def get_touch_time(self):
        """Calculate the touch_time normalized to [0,1] according to a sigmoid function"""
        # in the very first moment, a sharp sigmoid
        if self.touch_time < 0.07:
            return 1 / (1 + np.exp((self.sustain_dt * self.touch_time) + 4))

        # after the very first moment, a long sigmoid
        return 1 / (1 + np.exp(-self.touch_time + 4))

    def get_area(self):
        """Calculate the density of the touch's group. The density defined as the MAXIMAL distance between
        the main touch and one of the groupies"""
        if len(self.group) > 0:
            most_distant = 0
            for g in self.group:
                area = np.linalg.norm(np.array([self.main_touch.sx, self.main_touch.sy]) - g.spos)
                most_distant = max(area, most_distant)
            area = (most_distant - self.min_area) / (self.max_area - self.min_area)
            return max(0.0, min(area, 1.0))
        else:
            return 0.0

    def get_qualitiative_data(self):
        """Generate the data to be broadcast through UDP. The data is a list of concatenated values:
        [start_pos_x, start_pos_y, pos_x, pos_y, velocity, touch_time, mode, area]"""
        # if this channel is not active
        if not self.switch:
            return self.start_pos + [0.0] * 4 + [self.mode] + [0.0]

        position = self.get_positional_data()
        velocity = [min(1.0, self.velocity)]
        touch_time = [self.get_touch_time()]
        mode = [self.mode]
        area = [self.get_area()]
        return self.start_pos + position + velocity + touch_time + mode + area

    def __repr__(self):
        return "Id :{}, Active?: {},Position: {}".format(self.id, self.switch, [self.main_touch.sx, self.main_touch.sy])


class UDPclient:
    """
    Object represents the connection to the UDP, which holds for the communication with Max8.
    """

    def __init__(self):
        self.client = SimpleUDPClient(IP, CLIENT_PORT)

    def broadcast(self, data):
        for ch in range(len(data)):
            self.client.send_message('/channel%d'%(ch+1), data[ch][1])

class Printer:
    """
    Broadcaster to the screen
    """

    def broadcast(self, data):
        for ch in data:
            print(ch[0], ch[1])

class LSLbroadcast:
    """
    A wrapper for a broadcasting LSL connection
    """
    def __init__(self, channels, session_info_LSL):
        self.channels = channels
        self.conn = self.establishLSL(session_info_LSL)

    def establishLSL(self, session_info_LSL):
        self.info = StreamInfo(name="Touch events", type=session_info_LSL, channel_count=len(self.channels) * 2)
        self.outlet = StreamOutlet(self.info)
        print("-------------Outlet stream was created, LSL connections established successfully------------")
        print("-------------info type string: %s------------" % session_info_LSL)

    def broadcast(self, data):
        """
        Broadcasting the data to LSL connection
        """
        self.outlet.push_sample(data)

class DataBroadcaster:

    def __init__(self, channels):
        self.channels = channels
        self.positional_clients = self.initialize_positional_clients()
        self.generated_data_clients = self.initialize_generated_data_clients_clients()

    def initialize_positional_clients(self):
        list = []
        if SEND_TO_LSL:
            list.append(LSLbroadcast(self.channels, self.generate_type_string()))
        return list

    def initialize_generated_data_clients_clients(self):
        list = []
        list.append(UDPclient())
        if PRINT_DATA:
            list.append(Printer())
        return list

    def generate_type_string(self):
        return "Origin: " + parameters[0] +\
               ", " + "Grid: " + parameters[1]

    def broadcast(self, *args):
        """
        Broadcasting the data from channels to the customers.
        1st customer is LSL connection
        2nd customer is UDP client
        Data is a list of float numbers, in the shape:
        (Time, Channels), where "Time" is the time stamp and channels is the number of channels defined by the run.
        In order to plot the data correctly, a transposition needs to be applied
        """

        # Prepare data
        generated_data = []
        positional_data = []
        for ch in self.channels:
            positional_data += ch.get_pos_as_list()
            generated_data.append(["channel%d" % ch.get_channel_id(), ch.get_qualitiative_data()])

        # Broadcasting the positional_data (i.e to LSL)
        for client in self.positional_clients:
            client.broadcast(positional_data)

        # Broadcasting the generated_data (i.e to MAX)
        for client in self.generated_data_clients:
            client.broadcast(generated_data)


class TouchInput(Widget):
    """
    Handle the touch events that occurs determine what to do with them.
    Activations and deactivations of the channels happen here.
    """

    touch_time_threshold = MIN_TOUCH_TIME

    def __init__(self, channels, mouse_mode, **kwargs):
        super().__init__(**kwargs)
        self.channels = channels
        self.waiting_ch = TouchChannel(*parameters)
        self.touch_mode = "mouse" if mouse_mode else "wm_touch"

    def on_touch_down(self, touch):
        # If not touch mode type, do nothing
        if touch.device == self.touch_mode:
            for ch in [*self.channels, self.waiting_ch]:
                # If there is no active touch - create one
                if not ch.isActive():
                    if touch.is_double_tap:
                        ch.next_mode()
                    else:
                        ch.activate(touch)
                    return
                # If there is an active touch, and the current touch occurred immediately after it - Add to group
                if np.linalg.norm([ch.get_main_touch().spos[0] - touch.spos[0],
                                   ch.get_main_touch().spos[1] - touch.spos[1]]) < GROUPY_THRESHOLD:
                    ch.add_to_group(touch)
                    return

    def on_touch_move(self, touch):
        if touch.device == self.touch_mode:
            for ch in [*self.channels, self.waiting_ch]:
                if ch.get_main_touch() == touch:
                    ch.move()
                    return

    def on_touch_up(self, touch):
        if touch.device != self.touch_mode:
            return
        for ch in self.channels:
            # Case: The touch up refers to an active channel
            if touch == ch.get_main_touch():
                # Case: The channel have an active group => change the channel to one of the groupies
                if len(ch.get_group()) > 0:
                    new_touch = ch.get_group()[0]
                    ch.change_main_touch(new_touch)
                    ch.remove_from_group(new_touch)
                    break
                # Case: Waiting channel is active => Replace channels
                if self.waiting_ch.isActive():
                    ch.activate(self.waiting_ch.get_main_touch())
                    self.waiting_ch.deactivate()
                # else => deactivate
                else:
                    if ch.touch_time < self.touch_time_threshold:
                        ch.prev_mode()
                    ch.deactivate()
                break
            # Case: the touch up related to one of the channel's groupies (in this case
            # the channels must be activated) => remove it from the group
            if touch in ch.get_group():
                ch.remove_from_group(touch)
                break
        if self.waiting_ch.get_main_touch() == touch:
            self.waiting_ch.deactivate()


class MyApp(App):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.channels = [TouchChannel(*parameters) for ch in range(CHANNELS)]
        self.broadcaster = DataBroadcaster(self.channels)

    def build(self):
        Clock.schedule_interval(self.broadcaster.broadcast, TIME_SERIES_DT)
        return TouchInput(self.channels, mouse_mode=MOUSE_DEV_MODE)

if __name__ == "__main__":

    if FULL_WINDOW:
        # Avoiding the user from accidentally close the app
        Window.fullscreen = True
        Window.borderless = True
        Window.maximize()

    # App closes ONLY if <escape> is pressed
    Window.exit_on_escape = True

    # Run the app
    MyApp().run()
